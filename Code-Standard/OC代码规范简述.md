# OC-代码规范简述



为什么要写这篇文章呢？

      1、为了代码整洁；
      2、为了自己阅读方便；
      3、为了他人阅读方便。
      敲代码很简单，怎么能把简单的事做的专业，做的高大上! 那就要学会包装，格式、语法要整洁、规范。

参考资料：[苹果代码规范](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html#//apple_ref/doc/uid/10000146-SW1) 
参考链接：https://www.jianshu.com/p/c85f4a0bba4d



## 一、基本原则



1.  所有类、方法、属性等命名，做到见名知意，采用驼峰式命名规则。

2. 类名以大写驼峰式命名。每个单词首字母大写。枚举的命名和类的命名相近。

3. 项目中所有名称不要使用汉字命名，尽量使用英文命名，国内特有名词可以使用拼音。

4. 单一原则:一个变量一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。

5. 宏名全部大写，单词与单词之间用 `_` 连接。[不带参数]

   ```css
   #define HOME_PAGE_DID_SCROLL @"com.xq.home.page.tableview.did.scroll"
   ```

6. 宏名以 `k`  开头的。后面遵循大写驼峰命名。[不带参数]

   ```css
   #define kHomePageDidScroll @"com.xq.home.page.tableview.did.scroll"
   ```

7. 每个类型的命名以该类型结尾。

   > a、ViewController：使用 `ViewController` 结尾。例子：ApplyRecordsViewController
   >
   > b、View：使用 `View` 结尾。例子：分界线：boundaryView
   >
   > c、NSArray：使用 `s` 结尾。比如商品分类数据源。categories
   >
   > d、UITableViewCell：使用 `Cell` 结尾。比如 MyProfileCell
   >
   > e、Protocol：使用 `Delegate` 或者 `Datasource` 结尾。比如 XQScanViewDelegate
   >
   > f、Tool：工具类
   >
   > g、代理类：Delegate
   >
   > h、Service 类：Service

8. 添加必要代码的注释。

9. 删除没必要的代码，可通过git等追溯找回，没必要保留。

10. 根据资源类型或者所属业务逻辑对项目资源进行分组，使得整个项目结构清晰明了。

11. 单页代码最好控制在800行以内，每个方法最好不要超过100行，过多建议对代码进行重构

12. 相同的逻辑方法定义避免在多个地方出现，尽量将公用的类、方法抽取出来。

13. 在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。

14. 提供一个统一的数据管理入口，统一的数据管理入口会使得代码变得更容易管理和维护。

15. 请多使用 #pragma mark - Mark Name 对方法进行分组。

16. 项目整体代码风格要统一，让你的代码变的优雅！

    > a、代码后面的”{“ 不需要单独占用一行   
    >
    > b、逻辑运算符 与 代码之间空一格  
    >
    > c、“#pragma mark -” 与下面的代码之前不要空行  

17. 延后原则。

    > a、头文件能在.m中引入就不要在.h中引入，可以使用前向声明。
    >
    > b、能用临时变量就不用成员变量，能用成员变量就不用属性，能在.m中做声明就不在.h中做声明。
    >
    > c、尽可能少的在.h中暴露方法。

18. 减少单例的使用。

19. 单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。

    单例的使用场景概括如下：

    > a、控制资源的使用，通过线程同步来控制资源的并发访问。
    >
    > b、控制实例的产生，以达到节约资源的目的。
    >
    > c、控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。

## 二、方法

1. 方法与方法之间间隔一行。

2. 大量的方法尽量要以组的形式放在一起。

3. 方法最后面的括号需要另起一行。遵循 Apple 的规范。

4. 对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。

5. 如果方法参数过多过长，建议多行书写。用冒号进行对齐。

6. 一个方法内的代码最好保持在50行以内。

7. 一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。

8. 对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。

9. 函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。

10. 多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用。

11. 方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。

12. `.m` 文件中的私有方法需要在顶部进行声明

13. 方法组之间也有个顺序问题。

    > a、在文件最顶部实现属性的声明、私有方法的声明。
    >
    > b、在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。
    >
    > c、所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。

文件基本上就是：

```objective-c
//___FILEHEADER___

#import "___FILEBASENAME___.h"
/*ViewController*/

/*View&&Util*/

/*model*/

/*NetWork InterFace*/

/*Vender*/
```



### 三、文件组织结构

iOS工程文件结构分物理结构和逻辑结构，建议逻辑结构和物理结构保持一致，以便方便有效地管理类文件。类文件组织要遵循以下两大原则：

基于MVC设计模式原则，至少要保证controller与数据处理，网络请求相对独立

基于功能模块原则，功能模块分包括数据/网络处理，UI前端界面两部分，数据/网络处理应该在数据/网络处理的框架下，而UI前端界面比如用户中心，消息中心，它们的专有的controller，view等应该在属于文件夹。还会遇到一些公共的view，可以开辟出公共的文件夹来管理

在实际中使用中，项目实际负责人可以结合项目特点灵活使用，但基本的原则一定要保持，保持良好的类文件组织结构，对团队有益无害。

## 四、图片资源

1. 单个文件的命名
   
   > 文件资源的命名也需要一定的规范，形式为：功能模块名*类别*功能_状态@nx.png
   > Setting_Button_search_selected@2x.png、Setting_Button_search_selected@3x.png
   > Setting_Button_search_unselected@2x.png、Setting_Button_search_unselected@3x.png
2. 资源的文件夹命名
   
   > 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。

## 五、注释

1. 对于类的注释写在当前类文件的顶部
2. 对于属性的注释需要写在属性后面的地方。 //**/
3. 对于 .h 文件中方法的注释，一律按快捷键 `command+option+/`。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释
4. 对于 .m 文件中的方法的注释，在方法的旁边添加 `//`。
5. 注释符和注释内容需要间隔一个空格。 例如： // fetch goods list

## 六、版本规范

采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据

|  版本号   |    右说明对齐标题    |      示例      |
| :-------: | :------------------: | :------------: |
| **A**.b.c |  属于重大内容的更新  | 1.0.2 -> 2.0.0 |
| a.**B**.c | 属于小部分内容的更新 | 1.0.2 -> 1.1.1 |
| a.b.**C** |     属于补丁更新     | 1.0.2 -> 1.0.3 |





