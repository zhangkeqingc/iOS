# iOS App启动优化



**冷启动**
**热启动 **



**App启动时间，从点击 App 开始到用户看到第一个界面之间的时间。包括三个阶段：**

```
1、main() 函数执行前；
2、main() 函数执行后；
3、首屏渲染完成后。
```



**1、main() 函数执行前，系统主要会做下面几件事情：**

```
1、加载可执行文件（App 的.o 文件的集合）；
2、加载动态链接库，进行 rebase 指针调整和 bind 符号绑定；
3、Objc运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等；
4、初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。
```

```
简单来说， App启动后，首先，系统内核（Kernel）创建一个进程。 其次，加载可执行文件。（可执行文件是指Mach-O格式的文件，也就是App中所有.o文件的集合体）这时，能获取到dyld（dyld是苹果的动态链接器）的路径。 然后，加载dyld，主要分为4步：
1、load dylibs：这一阶段dyld会分析应用依赖的dylib，找到其mach-o文件，打开和读取这些文件并验证其有效性，接着会找到代码签名注册到内核，最后对dylib的每一个segment调用mmap()。 
2、rebase/bind：进行rebase指针调整和bind符号绑定。
3、ObjC setup：runtime运行时初始化。包括ObjC相关Class的注册、category注册、selector唯一性检查等。 
4、Initializers：调用每个ObjC类与分类的+load方法，调用attribute((constructor))修饰的函数、创建C++静态全局变量。
```



**1.1这个阶段对于启动速度优化来说，可以做的事情包括：**

```
1、减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司建议最多使用 6 个非系统动态库。
2、减少加载启动后不会去使用的类或者方法。+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。
3、控制 C++ 全局变量的数量。
```



**2、main() 函数执行后**

```
main函数执行后的阶段，指的是：从 main 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 即，从main函数执行到设置self.window.rootViewController执行完成的阶段。
首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：
1、首屏初始化所需配置文件的读写操作；
2、首屏列表大数据的读取；
3、首屏渲染的大量计算等。
```



**3、首屏渲染完成后**

```
首屏渲染完成后的阶段，指的是：didFinishLaunchingWithOptions方法作用域 内执行首屏渲染后的所有方法执行。 即从设置self.window.rootViewController到didFinishLaunchWithOptions方法作用域结束。
需要做的事：
1、初始化一些首屏展示不需要的功能。
2、优化主线程，先处理会卡住主线程的方法，不能影响到用户的后续操作。
```



**功能级别的启动优化**

 ```
优化的思路是： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，
其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。
 ```



**方法级别的启动优化**
检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。

那么，你觉得是不是只需要优化对资源的操作就可以了呢？当然不是。就像 +load() 方法，一个耗时 4 毫秒，100 个就是 400 毫秒，这种耗时用户也是能明显感知到的。比如，我以前使用的 ReactiveCocoa 框架（这是一个 iOS 上的响应式编程框架），每创建一个信号都有 6 毫秒的耗时。这样，稍不注意各种信号的创建就都被放在了首屏渲染完成前，进而导致 App 的启动速度大幅变慢。类似这样单个方法耗时不多，但是由于堆积导致 App 启动速度大幅变慢的方法数不胜数。所以，你需要一个能够对启动方法耗时进行全面、精确检查的手段。

那么问题来了，有哪些监控手段？这些监控手段各有什么优缺点？你又该如何选择呢？目前来看，对 App 启动速度的监控，主要有两种手段。第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。Xcode 工具套件里自带的 Time Profiler ，采用的就是这种方式。这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的 App 中，以便在真实环境中进行检查。说到定时抓取，就会涉及到定时间隔的长短问题。定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。这个定时间隔如果小于所有方法执行的时间（比如 0.002 秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。第二种方法是，对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。



